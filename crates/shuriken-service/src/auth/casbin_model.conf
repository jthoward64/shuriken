
; Note: in real use principal names are uuids not names
;
; Example tree:
; /calendars/
;   alice/
;     personal/
;       pets/
;         event1.ics
;         event2.ics
;       work/
;         event3.ics
;     work/
;       event4.ics
;   bob/
;     personal/
;       event5.ics
;     shared/
;       event6.ics
;       event7.ics
;   bossman/
;     reports/
;       event8.ics
;       event9.ics
;   cio/
;     personal/
;   team/
;     group-bonding/
;       event10.ics
;       event11.ics
; /addressbooks/
;   alice/
;     contacts/
;       contact1.vcf
;       contact2.vcf
;   bob/
;     contacts/
;       contact3.vcf
;   team/
;     directory/
;       alice.vcf
;       bob.vcf
;
; Bob, Alice, Bossman, and the CIO all own their personal calendars and addressbooks.
;
; Bob has made a public link to his shared calendar, so `public` has read access
;
; Bob, Alice, and Bossman are members of the "Team" group.
; The Team group has read access to the team calendar and addressbook.
; Bossman has edit-share access to the team calendar and addressbook.
; The CIO has read access to everything in the system.
;
; Bob manages dog sitting for Alice and has read access to her pets calendar, but also sometimes shares it with others.
;
; The team calendar is owned by the CIO.
; The team addressbook is owned by the CIO.
;
; This shakes out to:
; principal:bob - owner - /calendars/bob/**
; principal:bob - owner - /addressbooks/bob/**
; principal:bob - read-share - /calendars/alice/personal/pets/*
; principal:alice - owner - /calendars/alice/**
; principal:alice - owner - /addressbooks/alice/**
; principal:alice - read - /calendars/alice/personal/pets/*
; principal:bossman - owner - /calendars/bossman/**
; principal:bossman - owner - /addressbooks/bossman/**
; principal:bossman - edit-share - /calendars/team/**
; principal:bossman - edit-share - /addressbooks/team/**
; principal:cio - owner - /calendars/cio/**
; principal:cio - owner - /addressbooks/cio/**
; principal:cio - owner - /calendars/team/**
; principal:cio - owner - /addressbooks/team/**
; principal:cio - read - /calendars/**
; principal:cio - read - /addressbooks/**
; principal:team - read - /calendars/team/**
; principal:team - read - /addressbooks/team/**
; public - read - /calendars/bob/shared/*
;
; ** means "any depth" (Usually for an entire user/group namespace)
; * means "one level" (this should only be used for terminal collections, i.e. the glob that matches individual items).


; List of permissions:
; - read_freebusy: View free/busy information
; - read: View an item's details or a collection's contents
; - edit: Modify an item's details or a collection's contents
; - delete: Remove an item or collection
; - share_read: Add/remove a sharee with read access
; - share_edit: Add/remove a sharee with edit access
; - admin: Add/remove a sharee with share_read/share_edit access or change collection properties like name and whatnot

; List of role grants
; reader-freebusy => read_freebusy
; reader => read_freebusy, read
; editor-basic => read_freebusy, read, edit
; editor => read_freebusy, read, edit, delete
; share-manager => read_freebusy, read, edit, delete, share_read, share_edit
; admin => read_freebusy, read, edit, delete, share_read, share_edit, admin

[request_definition]
; sub: the user or entity making the request - `principal:${uuid}` (for user or group) or `public`
; path: the resource being accessed - /.../${collection}/${item} or maybe /.../${collection}/ or /.../${collection1}/${collection2}/item
; action: the action being performed - e.g. "read", "read_freebusy", "edit", "delete", "share_read", "share_edit"
r = sub, path, action

[policy_definition]
; sub, path, role
; sub: the user or entity - `principal:${uuid}` (for user or group) or `public`
; path: the path pattern the policy applies to - e.g. /calendars/team/* or /addressbooks/alice/*
; role: the role granted to this user on this resource
p = sub, path, role

[role_definition]
; g2 defines role -> permission mappings
; These are loaded as policies and define which permissions each role grants
; e.g., g2, reader-freebusy, read_freebusy
;       g2, reader, read_freebusy
;       g2, reader, read
;       g2, editor-basic, read_freebusy
;       g2, editor-basic, read
;       g2, editor-basic, edit
;       etc.
g = _, _
g2 = _, _

[policy_effect]
; Allow if any matching policy grants access
e = some(where (p.eft == allow))

[matchers]
; Match if:
; 1. Subject matches (direct or via group membership - expanded before enforcement)
; 2. Path matches the policy path pattern (glob matching with * and **)
; 3. Role grants the requested action/permission via g2 relation
m = r.sub == p.sub && globMatch(r.path, p.path) && g2(p.role, r.action)