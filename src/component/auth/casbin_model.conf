; -------------------------------------------------------------------
; ReBAC-style model for CalDAV/CardDAV with:
; - Direct sharing to users, groups, and "public"
; - Flat groups only (users belong to groups; groups are NOT nested)
; - Container membership (events in calendars, vcards in addressbooks)
; - Type-based permissions (policies written per resource type)
;
; NOTE ON GROUPS + PUBLIC:
; This model keeps the matcher simple and does NOT traverse user->group
; membership inside the matcher. Instead, your application should expand
; the effective subjects at enforcement time:
;
;   effective_subjects(user) = { user } ∪ groups(user) ∪ { public }
;
; and allow if ANY subject in that set is allowed by Enforce().
;
; Example enforcement for user:alice:
;   Enforce("user:alice", obj, act)
;   Enforce("group:eng",  obj, act)   ; for each group alice is in
;   Enforce("public",     obj, act)   ; public grants (if any)
;
; This avoids custom functions and works well for flat groups.
; -------------------------------------------------------------------

[request_definition]
; sub: principal (e.g., "user:alice", "group:eng", "public")
; obj: resource instance (e.g., "cal:team", "evt:team:123", "ab:alice", "card:alice:456")
; act: action string (e.g., "read_freebusy", "read", "write", "share_grant:read")
r = sub, obj, act

[policy_definition]
; role: MINIMUM permission level required on a resource, e.g.:
;   "read-freebusy", "read", "read-share", "edit", "edit-share", "admin", "owner"
; obj_type: resource type, e.g.:
;   "calendar", "calendar_event", "addressbook", "vcard"
; act: action
p = role, obj_type, act

[role_definition]
; g(principal, resource, role)
; Principal-to-resource relationship edges (sharing grants):
;   g, user:alice,  cal:team, owner
;   g, group:eng,   cal:team, edit
;   g, public,      cal:holidays, read
g = _, _, _

; g2(resource, obj_type)
; Resource typing edges:
;   g2, cal:team, calendar
;   g2, evt:team:123, calendar_event
;   g2, ab:alice, addressbook
;   g2, card:alice:456, vcard
g2 = _, _

; g3(user, group)
; Flat user-to-group membership edges:
;   g3, user:alice, group:eng
; (NOT used in the matcher; used by your app to expand effective subjects)
g3 = _, _

; g4(child, parent)
; Resource membership/containment edges:
;   g4, evt:team:123, cal:team
;   g4, card:alice:456, ab:alice
g4 = _, _

; g5(higher, lower)
; Permission hierarchy edges so higher levels imply lower ones:
;   g5, owner, admin
;   g5, admin, edit-share
;   g5, edit-share, edit
;   g5, edit, read-share
;   g5, read-share, read
;   g5, read, read-freebusy
;
; Add these edges to your policy store (casbin_rule) so you don't have to
; duplicate policies for every higher role.
g5 = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
; Authorization rule:
; Allow if principal has SOME granted role (permission level) that
; implies the policy-required minimum role, either:
;   - directly on the object, OR
;   - on the object's parent container (calendar/addressbook), if one exists,
; AND the object is of the policy's type, AND the action matches.
m =
  (
    (g(r.sub, r.obj, granted) && (granted == p.role || g5(granted, p.role)))
    ||
    (g4(r.obj, parent) && g(r.sub, parent, granted) && (granted == p.role || g5(granted, p.role)))
  )
  &&
  g2(r.obj, p.obj_type)
  &&
  r.act == p.act